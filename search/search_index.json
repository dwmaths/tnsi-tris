{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Retour sur les tris","text":""},{"location":"#implantation-des-tris","title":"Implantation des tris","text":"<p>On propose ci-dessous d'implanter dans un m\u00eame fichier python, les deux fonctions permettant de r\u00e9aliser :</p> <ul> <li>le tri par s\u00e9lection ;</li> <li>le tri par insertion.</li> </ul> <p>Pour commencer, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  tris.py</p>"},{"location":"#le-tri-par-selection","title":"Le tri par s\u00e9lection","text":"<p>On rappelle que le tri par s\u00e9lection repose sur l'\u00e9change entre l'\u00e9l\u00e9ment d'indice \\(i\\) et le minimum de la liste \u00e0 partir de l'indice \\(i\\).</p> <p> </p> <p>Pour r\u00e9aliser un tri par s\u00e9lection, on propose la structure de code suivante :</p> Implantation du tri par s\u00e9lection<pre><code>def tri_selection(L:list) -&gt; None:\n    \"\"\"\n        R\u00e9alise un tri par s\u00e9lection d'une liste L\n    \"\"\"\n    n = len(L)\n    for i in range(...):\n        mini = ...\n        for j in range(..., ...):\n            if L[...] &lt; L[...]:\n                mini = ...\n        if i != mini:\n            L[i], L[mini] = L[mini], L[i]\n</code></pre> <p>Pour commencer</p> <ol> <li>Compl\u00e9ter le code ci-dessus pour qu'il r\u00e9alise un tri complet par s\u00e9lection.</li> <li>D\u00e9finir la variable <code>L = [14, 4, 19, 12, 7, 2, 10, 24, 9]</code>.<ol> <li>Que renvoie l'instruction <code>tri_selection(L)</code> ?</li> <li>V\u00e9rifier que la liste est bien tri\u00e9e malgr\u00e9 tout.</li> <li>Combien de comparaisons ont \u00e9t\u00e9 utilis\u00e9es pour trier cette liste ?</li> </ol> </li> </ol> Correction <p>On donne ci-dessous le code complet pour la fonction <code>tri_selection(L:list) -&gt; None</code> :</p> Implantation du tri par s\u00e9lection<pre><code>def tri_selection(L:list) -&gt; None:\n    \"\"\"\n        R\u00e9alise un tri par s\u00e9lection d'une liste L\n    \"\"\"\n    n = len(L)\n    for i in range(n-1):\n        mini = i\n        for j in range(i+1, n):\n            if L[j] &lt; L[mini]:\n                mini = j\n        if i != mini:\n            L[i], L[mini] = L[mini], L[i]\n</code></pre>"},{"location":"#le-tri-par-insertion","title":"Le tri par insertion","text":"<p>Contrairement au tri par s\u00e9lection, le tri par insertion repose sur le d\u00e9calage vers la gauche du \\(i\\)-i\u00e8me \u00e9l\u00e9ment tant qu'il n'est pas situ\u00e9 \u00e0 la bonne place.</p> <p> </p> <p>Pour r\u00e9aliser un tri par insertion, on propose la structure de code suivante :</p> Implantation du tri par insertion<pre><code>def tri_insertion(L:list) -&gt; None:\n    \"\"\"\n        R\u00e9alise un tri par insertion d'une liste L\n    \"\"\"\n    n = len(L)\n    for i in range(..., ...):\n        x = L[...]\n        j = ...\n\n        while ... and L[...] &gt; x:\n            L[j] = L[...]\n            j = j-1\n\n        L[j] = x\n</code></pre> <p>Pour commencer</p> <ol> <li>Compl\u00e9ter le code ci-dessus pour qu'il r\u00e9alise un tri complet par insertion.</li> <li>D\u00e9finir la variable <code>L = [\"David\", \"Laurie\", \"Bastien\", \"Alexis\", \"Edouard\", \"Lily\", \"Lea\", \"Juliette\"]</code>.<ol> <li>Que renvoie l'instruction <code>tri_insertion(L)</code> ?</li> <li>V\u00e9rifier que la liste est bien tri\u00e9e malgr\u00e9 tout.</li> <li>Combien de comparaisons ont \u00e9t\u00e9 utilis\u00e9es pour trier cette liste ? </li> </ol> </li> </ol> Correction <p>On donne ci-dessous le code complet pour la fonction <code>tri_insertion(L:list) -&gt; None</code> :</p> Implantation du tri par insertion<pre><code>def tri_insertion(L:list) -&gt; None:\n    \"\"\"\n        R\u00e9alise un tri par insertion d'une liste L\n    \"\"\"\n    n = len(L)\n    for i in range(1, n):\n        x = L[i]\n        j = i\n\n        while j &gt; 0 and L[j-1] &gt; x:\n            L[j] = L[j-1]\n            j = j-1\n\n        L[j] = x\n</code></pre>"},{"location":"#application-sur-des-donnees-abstraites","title":"Application sur des donn\u00e9es abstraites","text":"<p>Une fuite de donn\u00e9es a concern\u00e9 le serveur pronote du lyc\u00e9e Colbert. On a pu r\u00e9cup\u00e9rer l'ensemble de la liste des \u00e9l\u00e8ves avec leur genre et leur date de naissance.</p>"},{"location":"#modelisation","title":"Mod\u00e9lisation","text":"<p>Pour mod\u00e9liser un \u00e9l\u00e8ve du lyc\u00e9e Colbert, on propose d'utiliser un tuple nomm\u00e9 avec trois attributs :</p> <ul> <li>l'identit\u00e9 de l'\u00e9l\u00e8ve ;</li> <li>le genre de l'\u00e9l\u00e8ve (<code>\"G\"</code> ou <code>\"F\"</code>) ;</li> <li>la date de naissance de l'\u00e9l\u00e8ve.</li> </ul> <p>Pour commencer, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  colbert.py</p> <p>Cr\u00e9ation d'un \u00e9l\u00e8ve</p> <ol> <li>Proposer un code permettant d'implanter la fonction <code>creer_date(d:str) -&gt; tuple</code> ;</li> <li>\u00c0 l'aide de cette fonction, compl\u00e9ter le code de la fonction <code>creer_eleve(L:list) -&gt; tuple</code>.</li> </ol> Indications <ol> <li>Pour convertir une chaine de caract\u00e8res en entier, on utilise la fonction <code>int</code>. Il faut \u00e9galement couper la chaine de caract\u00e8res avec la m\u00e9thode <code>split</code>.</li> <li>Associer les \u00e9l\u00e9ments de la liste aux bons attributs du tuple.</li> </ol> Correction <ol> <li>Pour la fonction <code>creer_date(d:str) -&gt; tuple</code>, on propose le code :</li> </ol> <p>Cr\u00e9ation d'une date<pre><code>def creer_date(d:str) -&gt; tuple:\n    \"\"\"\n        Convertir une chaine \"jj/mm/aaaa\" en tuple (jj, mm, aaaa)\n    \"\"\"\n    buff = d.split('/')\n    return (int(buff[0]), int(buff[1]), int(buff[2]))\n</code></pre> 2. Pour la fonction <code>creer_eleve(L:list) -&gt; tuple</code>, on a alors :</p> Cr\u00e9ation d'un \u00e9l\u00e8ve<pre><code>def creer_eleve(L:list) -&gt; tuple:\n    \"\"\"\n        Cr\u00e9er un \u00e9l\u00e8ve \u00e0 partir d'une liste de chaine de caract\u00e8res.\n    \"\"\"\n    return eleve(L[0], L[2], creer_date(L[1]))\n</code></pre>"},{"location":"#chargement-des-donnees","title":"Chargement des donn\u00e9es","text":"<p>Pour commencer, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  eleves.csv ainsi que le fichier de test test.csv.</p> <p>Quelques essais</p> <ol> <li> <p>Dans la console, taper les instructions :</p> <ul> <li><code>f = open(\"test.csv\", encoding=\"utf-8\")</code> ;</li> <li><code>L = f.readlines()</code> ;</li> <li><code>f.close()</code>.</li> </ul> </li> <li> <p>Observer ce que contient la liste <code>L</code>.</p> </li> <li>Taper alors l'instruction <code>L = [el[:-1] for el in L]</code> puis observer \u00e0 nouveau la liste <code>L</code>.</li> <li>Taper enfin l'instruction <code>L = [el.split(',') for el in L]</code> puis observer \u00e0 nouveau la liste <code>L</code>.</li> <li>Proposer un code complet de la fonction <code>charger_data() -&gt; list</code> qui charge les \u00e9l\u00e8ves du fichier eleves.csv.</li> </ol> Correction <p>Pour la fonction <code>charger_data() -&gt; list</code>, on propose le code suivant :</p> Chargement des \u00e9l\u00e8ves<pre><code>def charger_data() -&gt; list:\n    \"\"\"\n        Chargement des \u00e9l\u00e8ves depuis le fichier eleves.csv\n    \"\"\"\n    f = open(\"eleves.csv\", encoding=\"utf-8\")\n    L = f.readlines()\n    f.close()\n    L = [el[:-1].split(',') for el in L]\n\n    res = []\n    for elt in L:\n        res.append(creer_eleve(elt))\n    return res\n</code></pre>"},{"location":"#tris-et-comparaisons-deleves","title":"Tris et comparaisons d'\u00e9l\u00e8ves","text":"<p>Pour aller plus loin</p> <ol> <li>V\u00e9rifier que l'instruction <code>colbert = charger_data()</code> charge bien l'ensemble des \u00e9l\u00e8ves du lyc\u00e9e.</li> <li>Trier cette liste avec un tri par s\u00e9lection et observer le classement par ordre alphab\u00e9tique.</li> <li>Implanter dans le fichier tris.py une m\u00e9thode <code>cmp_eleve(el1:tuple, el2:tuple) -&gt; int</code> qui compare les \u00e9l\u00e8ves suivant la r\u00e8gle :<ul> <li>si l'\u00e9l\u00e8ve 1 est plus jeune que l'\u00e9l\u00e8ve 2, alors cette fonction renvoie 1 ;</li> <li>si l'\u00e9l\u00e8ve 1 est plus vieux que l'\u00e9l\u00e8ve 2, alors cette fonction renvoie -1 ;</li> <li>si l'\u00e9l\u00e8ve est n\u00e9 le m\u00eame jour que l'\u00e9l\u00e8ve 2, alors on trie par ordre alphab\u00e9tique du nom.</li> </ul> </li> <li>Modifier alors la fonction tri_insertion pour prendre en compte cette fonction de comparaison.</li> <li>Trier la liste <code>colbert</code> gr\u00e2ce \u00e0 un tri par insertion.</li> </ol>"}]}